! (C) Copyright 1988- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
!
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

MODULE CLOUDSC_GLOBAL_STATE_MOD
  ! Driver module to manage the setup and teardown of the dwarf memory state
  USE PARKIND1,  ONLY : JPIM, JPRB
  USE YOMPHYDER, ONLY : STATE_TYPE
  USE YOECLDP,   ONLY : NCLV, YRECLDP, YRECLDP_LOAD_PARAMETERS
  USE YOMCST,    ONLY : YOMCST_LOAD_PARAMETERS
  USE YOETHF,    ONLY : YOETHF_LOAD_PARAMETERS
  USE YOEPHLI  , ONLY : YREPHLI, YREPHLI_LOAD_PARAMETERS

  USE FILE_IO_MOD, ONLY: INPUT_INITIALIZE, INPUT_FINALIZE, LOAD_SCALAR, LOAD_ARRAY
  USE EXPAND_MOD, ONLY: LOAD_AND_EXPAND, LOAD_AND_EXPAND_STATE
  USE VALIDATE_MOD, ONLY: VALIDATE
  USE CLOUDSC_MPI_MOD, ONLY: IRANK

  IMPLICIT NONE

  TYPE CLOUDSC_GLOBAL_STATE
    ! Memory state containing raw fields annd tendencies for CLOUDSC dwarf
    !
    ! Note that the global state has an additional outermost block
    ! dimension allocated for each field variable.
    INTEGER(KIND=JPIM)                   :: NPROMA, KLEV    ! Grid points and vertical levels per block
    INTEGER(KIND=JPIM)                   :: NGPTOT, NBLOCKS ! Total number of grid points and blocks
    INTEGER(KIND=JPIM)                   :: KFLDX 
    LOGICAL                              :: LDSLPHY 
    LOGICAL                              :: LDMAINCALL      ! T if main call to cloudsc
    REAL(KIND=JPRB)                      :: PTSPHY          ! Physics timestep

    ! Input field variables and tendencies
    REAL(KIND=JPRB), ALLOCATABLE :: PLCRIT_AER(:,:,:) 
    REAL(KIND=JPRB), ALLOCATABLE :: PICRIT_AER(:,:,:) 
    REAL(KIND=JPRB), ALLOCATABLE :: PRE_ICE(:,:,:) 
    REAL(KIND=JPRB), ALLOCATABLE :: PCCN(:,:,:)     ! liquid cloud condensation nuclei
    REAL(KIND=JPRB), ALLOCATABLE :: PNICE(:,:,:)    ! ice number concentration (cf. CCN)

    REAL(KIND=JPRB), ALLOCATABLE :: PT(:,:,:)       ! T at start of callpar
    REAL(KIND=JPRB), ALLOCATABLE :: PQ(:,:,:)       ! Q at start of callpar
    TYPE(STATE_TYPE), ALLOCATABLE :: TENDENCY_CML(:) ! cumulative tendency used for final output
    TYPE(STATE_TYPE), ALLOCATABLE :: TENDENCY_TMP(:) ! cumulative tendency used as input
    TYPE(STATE_TYPE), ALLOCATABLE :: TENDENCY_LOC(:) ! local tendency from cloud scheme
    REAL(KIND=JPRB), ALLOCATABLE :: PVFA(:,:,:)     ! CC from VDF scheme
    REAL(KIND=JPRB), ALLOCATABLE :: PVFL(:,:,:)     ! Liq from VDF scheme
    REAL(KIND=JPRB), ALLOCATABLE :: PVFI(:,:,:)     ! Ice from VDF scheme
    REAL(KIND=JPRB), ALLOCATABLE :: PDYNA(:,:,:)    ! CC from Dynamics
    REAL(KIND=JPRB), ALLOCATABLE :: PDYNL(:,:,:)    ! Liq from Dynamics
    REAL(KIND=JPRB), ALLOCATABLE :: PDYNI(:,:,:)    ! Liq from Dynamics
    REAL(KIND=JPRB), ALLOCATABLE :: PHRSW(:,:,:)    ! Short-wave heating rate
    REAL(KIND=JPRB), ALLOCATABLE :: PHRLW(:,:,:)    ! Long-wave heating rate
    REAL(KIND=JPRB), ALLOCATABLE :: PVERVEL(:,:,:)  ! Vertical velocity
    REAL(KIND=JPRB), ALLOCATABLE :: PAP(:,:,:)      ! Pressure on full levels
    REAL(KIND=JPRB), ALLOCATABLE :: PAPH(:,:,:)     ! Pressure on half levels
    REAL(KIND=JPRB), ALLOCATABLE :: PLSM(:,:)       ! Land fraction (0-1) 
    LOGICAL,         ALLOCATABLE :: LDCUM(:,:)      ! Convection active
    INTEGER(KIND=JPIM), ALLOCATABLE :: KTYPE(:,:)   ! Convection type 0,1,2
    REAL(KIND=JPRB), ALLOCATABLE :: PLU(:,:,:)      ! Conv. condensate
    REAL(KIND=JPRB), ALLOCATABLE :: PLUDE(:,:,:)    ! Conv. detrained water 
    REAL(KIND=JPRB), ALLOCATABLE :: PSNDE(:,:,:)    ! Conv. detrained snow
    REAL(KIND=JPRB), ALLOCATABLE :: PMFU(:,:,:)     ! Conv. mass flux up
    REAL(KIND=JPRB), ALLOCATABLE :: PMFD(:,:,:)     ! Conv. mass flux down
    REAL(KIND=JPRB), ALLOCATABLE :: PA(:,:,:)       ! Original Cloud fraction (t)
    REAL(KIND=JPRB), ALLOCATABLE :: PEXTRA(:,:,:,:) ! extra fields
    REAL(KIND=JPRB), ALLOCATABLE :: PCLV(:,:,:,:) 
    REAL(KIND=JPRB), ALLOCATABLE :: PSUPSAT(:,:,:)

    ! Output fields used for validation
    REAL(KIND=JPRB), ALLOCATABLE :: PCOVPTOT(:,:,:) ! Precip fraction
    REAL(KIND=JPRB), ALLOCATABLE :: PRAINFRAC_TOPRFZ(:,:) 
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQLF(:,:,:)   ! Flux of liquid
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQIF(:,:,:)   ! Flux of ice
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQLNG(:,:,:)  ! -ve corr for liq
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQNNG(:,:,:)  ! -ve corr for ice
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQRF(:,:,:)   ! Flux diagnostics
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQSF(:,:,:)   ! for DDH, generic
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQRNG(:,:,:)  ! rain
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQSNG(:,:,:)  ! snow
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQLTUR(:,:,:) ! liquid flux due to VDF
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQITUR(:,:,:) ! ice flux due to VDF
    REAL(KIND=JPRB), ALLOCATABLE :: PFPLSL(:,:,:)   ! liq+rain sedim flux
    REAL(KIND=JPRB), ALLOCATABLE :: PFPLSN(:,:,:)   ! ice+snow sedim flux
    REAL(KIND=JPRB), ALLOCATABLE :: PFHPSL(:,:,:)   ! Enthalpy flux for liq
    REAL(KIND=JPRB), ALLOCATABLE :: PFHPSN(:,:,:)   ! Enthalp flux for ice

    ! Underlying data buffers for AOSOA allcoated STATE_TYPE arrays
    REAL(KIND=JPRB), ALLOCATABLE :: B_CML(:,:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: B_TMP(:,:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: B_LOC(:,:,:,:)

    REAL(KIND=JPRB), ALLOCATABLE :: ZIFG (:,:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: ZOFG (:,:,:,:)

    INTEGER(KIND=JPIM) :: IPLCRIT_AER,IPICRIT_AER,IPRE_ICE,&
    & IPCCN,IPNICE,&
    & IPT,IPQ,ITENDENCY_CML,ITENDENCY_TMP,ITENDENCY_LOC,&
    & IPVFA,IPVFL,IPVFI,IPDYNA,IPDYNL,IPDYNI,IPHRSW,&
    & IPHRLW,IPVERVEL,IPAP,IPAPH,IPLSM,IPLU,IPLUDE,&
    & IPSNDE,IPMFU,IPMFD,IPA,IPEXTRA, IPCLV,IPSUPSAT


   INTEGER(KIND=JPIM) ::  IPLUDEO,IPCOVPTOT, IPRAINFRAC_TOPRFZ, IPFSQLF,IPFSQIF,&
   & IPFCQLNG,IPFCQNNG,IPFSQRF,IPFSQSF, &
   & IPFCQRNG,IPFCQSNG,IPFSQLTUR,IPFSQITUR, &
   & IPFPLSL,IPFPLSN,IPFHPSL,IPFHPSN

  CONTAINS
    PROCEDURE :: LOAD => CLOUDSC_GLOBAL_STATE_LOAD
    PROCEDURE :: VALIDATE => CLOUDSC_GLOBAL_STATE_VALIDATE
  END TYPE CLOUDSC_GLOBAL_STATE

  INTERFACE FIELD_INIT
     PROCEDURE FIELD_INIT_R1, FIELD_INIT_R2, FIELD_INIT_R3, FIELD_INIT_STATE
  END INTERFACE FIELD_INIT

CONTAINS

  SUBROUTINE FIELD_INIT_R1(FIELD, NPROMA,NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), ALLOCATABLE, INTENT(INOUT) :: FIELD(:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       FIELD(:,B) = 0.0_JPRB
    END DO
!$omp end parallel do 
  END SUBROUTINE FIELD_INIT_R1

  SUBROUTINE FIELD_INIT_R2(FIELD, NPROMA, NLEV, NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), ALLOCATABLE, INTENT(INOUT) :: FIELD(:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NLEV, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       FIELD(:,:,B) = 0.0_JPRB
    END DO
!$omp end parallel do 
  END SUBROUTINE FIELD_INIT_R2

  SUBROUTINE FIELD_INIT_R3(FIELD, NPROMA, NLEV, NDIM, NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), ALLOCATABLE, INTENT(INOUT) :: FIELD(:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NDIM, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NLEV, NDIM, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       FIELD(:,:,:,B) = 0.0_JPRB
    END DO
!$omp end parallel do 
  END SUBROUTINE FIELD_INIT_R3

  SUBROUTINE FIELD_INIT_STATE(STATE, BUFFER, NPROMA, NLEV, NDIM, NBLOCKS)
    ! Allocate empty state struct array
    !
    ! Note, the resulting AOSOA pattern is a pain to roll by hand in Fortran
    ! and could be done either via parameterized derived types or templating.
    TYPE(STATE_TYPE), ALLOCATABLE, INTENT(INOUT) :: STATE(:)
    REAL(KIND=JPRB), ALLOCATABLE, TARGET, INTENT(INOUT) :: BUFFER(:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NDIM, NBLOCKS
    INTEGER(KIND=JPIM) :: B, NFIELDS

    NFIELDS = 3+NDIM
    ALLOCATE(STATE(NBLOCKS))
    ALLOCATE(BUFFER(NPROMA, NLEV, NFIELDS, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       STATE(B)%T => BUFFER(:,:,1,B)
       STATE(B)%A => BUFFER(:,:,2,B)
       STATE(B)%Q => BUFFER(:,:,3,B)
       STATE(B)%CLD => BUFFER(:,:,4:NFIELDS,B)
    END DO
!$omp end parallel do 
  END SUBROUTINE FIELD_INIT_STATE

  SUBROUTINE CLOUDSC_GLOBAL_STATE_LOAD(SELF, NPROMA, NGPTOT, NGPTOTG)
    ! Load reference input data via serialbox
    CLASS(CLOUDSC_GLOBAL_STATE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NGPTOT
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG

    INTEGER(KIND=JPIM) :: KLON,INEXT

    INEXT=1


    SELF%IPT              =INDRAD(INEXT,1,.TRUE.)
    SELF%IPQ              =INDRAD(INEXT,1,.TRUE.)
    SELF%IPA              =INDRAD(INEXT,1,.TRUE.)
    SELF%IPAP             =INDRAD(INEXT,1,.TRUE.)
    SELF%IPAPH            =INDRAD(INEXT,1,.TRUE.)
    SELF%IPSUPSAT         =INDRAD(INEXT,1,.TRUE.)
    SELF%IPLU             =INDRAD(INEXT,1,.TRUE.)
    SELF%IPSNDE           =INDRAD(INEXT,1,.TRUE.)
    SELF%IPMFU            =INDRAD(INEXT,1,.TRUE.)
    SELF%IPMFD            =INDRAD(INEXT,1,.TRUE.)
    SELF%IPHRSW           =INDRAD(INEXT,1,.TRUE.)
    SELF%IPHRLW           =INDRAD(INEXT,1,.TRUE.)
    SELF%IPRE_ICE         =INDRAD(INEXT,1,.TRUE.)
    SELF%IPICRIT_AER      =INDRAD(INEXT,1,.TRUE.)
    SELF%IPNICE           =INDRAD(INEXT,1,.TRUE.)
    SELF%IPLCRIT_AER      =INDRAD(INEXT,1,.TRUE.)

    SELF%IPCCN            =INDRAD(INEXT,1,.TRUE.)
    SELF%IPVFL            =INDRAD(INEXT,1,.TRUE.)
    SELF%IPVFI            =INDRAD(INEXT,1,.TRUE.)

    SELF%IPVERVEL         =INDRAD(INEXT,1,.TRUE.)

    SELF%IPVFA            =INDRAD(INEXT,1,.TRUE.)
    SELF%IPDYNA           =INDRAD(INEXT,1,.TRUE.)
    SELF%IPDYNL           =INDRAD(INEXT,1,.TRUE.)
    SELF%IPDYNI           =INDRAD(INEXT,1,.TRUE.)

    INEXT=1
    
    SELF%IPFPLSL        =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFPLSN        =OUTDRAD(INEXT,1,.TRUE.)
    
    SELF%IPFSQLF        =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFSQIF        =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFCQLNG       =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFCQNNG       =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFSQLTUR      =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFSQITUR      =OUTDRAD(INEXT,1,.TRUE.)

    SELF%IPFSQRF        =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFCQRNG       =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFCQSNG       =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFSQSF        =OUTDRAD(INEXT,1,.TRUE.)

 
    SELF%IPFHPSL        =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFHPSN        =OUTDRAD(INEXT,1,.TRUE.)

    print *,  SELF%IPFSQLF,  SELF%IPFSQIF,  SELF%IPFCQLNG, SELF%IPFCQNNG, SELF%IPFSQSF
    CALL INPUT_INITIALIZE(NAME='input')

    SELF%NBLOCKS = (NGPTOT / NPROMA) + MIN(MOD(NGPTOT,NPROMA), 1)
    CALL LOAD_SCALAR('KLON', KLON)
    CALL LOAD_SCALAR('KLEV', SELF%KLEV)
    CALL LOAD_SCALAR('KFLDX', SELF%KFLDX)

    CALL LOAD_AND_EXPAND('PLCRIT_AER', SELF%PLCRIT_AER, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)    
    ALLOCATE(SELF%ZIFG(NPROMA,SELF%KLEV+1,26, SELF%NBLOCKS))
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPLCRIT_AER,1:SELF%NBLOCKS)=SELF%PLCRIT_AER(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PLCRIT_AER)


    CALL LOAD_AND_EXPAND('PICRIT_AER', SELF%PICRIT_AER, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)    
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPICRIT_AER,1:SELF%NBLOCKS)=SELF%PICRIT_AER(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PICRIT_AER)


    CALL LOAD_AND_EXPAND('PRE_ICE', SELF%PRE_ICE, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPRE_ICE,1:SELF%NBLOCKS)=SELF%PRE_ICE(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PRE_ICE)
    
    CALL LOAD_AND_EXPAND('PCCN', SELF%PCCN, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPCCN,1:SELF%NBLOCKS)=SELF%PCCN(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PCCN)

    CALL LOAD_AND_EXPAND('PNICE', SELF%PNICE, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPNICE,1:SELF%NBLOCKS)=SELF%PNICE(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PNICE)

    CALL LOAD_AND_EXPAND('PT', SELF%PT, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPT,1:SELF%NBLOCKS)=SELF%PT(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
   DEALLOCATE(SELF%PT)

    CALL LOAD_AND_EXPAND('PQ', SELF%PQ, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPQ,1:SELF%NBLOCKS)=SELF%PQ(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PQ)

    CALL LOAD_AND_EXPAND('PVFA', SELF%PVFA, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPVFA,1:SELF%NBLOCKS)=SELF%PVFA(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PVFA)


    CALL LOAD_AND_EXPAND('PVFL', SELF%PVFL, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
        SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPVFL,1:SELF%NBLOCKS)=SELF%PVFL(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
        !print *, "_______________   ", SELF%PVFL(1,120,1), "     ", SELF%PVFL(1,120,2)
    DEALLOCATE(SELF%PVFL)

    CALL LOAD_AND_EXPAND('PVFI', SELF%PVFI, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
        SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPVFI,1:SELF%NBLOCKS)=SELF%PVFI(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
        !print *, "_______________   ", SELF%PVFL(1,120,1), "     ", SELF%PVFL(1,120,2)
    DEALLOCATE(SELF%PVFI)

    CALL LOAD_AND_EXPAND('PDYNA', SELF%PDYNA, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPDYNA,1:SELF%NBLOCKS)=SELF%PDYNA(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PDYNA)

    CALL LOAD_AND_EXPAND('PDYNL', SELF%PDYNL, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPDYNL,1:SELF%NBLOCKS)=SELF%PDYNL(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PDYNL) 

    CALL LOAD_AND_EXPAND('PDYNI', SELF%PDYNI, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPDYNI,1:SELF%NBLOCKS)=SELF%PDYNI(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PDYNI)

    CALL LOAD_AND_EXPAND('PHRSW', SELF%PHRSW, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPHRSW,1:SELF%NBLOCKS)=SELF%PHRSW(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PHRSW)

    CALL LOAD_AND_EXPAND('PHRLW', SELF%PHRLW, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPHRLW,1:SELF%NBLOCKS)=SELF%PHRLW(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PHRLW)

    CALL LOAD_AND_EXPAND('PVERVEL', SELF%PVERVEL, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPVERVEL,1:SELF%NBLOCKS)=SELF%PVERVEL(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PVERVEL)

    CALL LOAD_AND_EXPAND('PAP', SELF%PAP, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
        SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPAP,1:SELF%NBLOCKS)=SELF%PAP(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PAP)

    CALL LOAD_AND_EXPAND('PAPH', SELF%PAPH, KLON, SELF%KLEV+1, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
        SELF%ZIFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPAPH,1:SELF%NBLOCKS)=SELF%PAPH(1:NPROMA,1:SELF%KLEV+1,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PAPH)

    CALL LOAD_AND_EXPAND('PLSM', SELF%PLSM, KLON, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('LDCUM', SELF%LDCUM, KLON, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('KTYPE', SELF%KTYPE, KLON, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PLU', SELF%PLU, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
     SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPLU,1:SELF%NBLOCKS)=SELF%PLU(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PLU)

    CALL LOAD_AND_EXPAND('PLUDE', SELF%PLUDE, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PSNDE', SELF%PSNDE, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPSNDE,1:SELF%NBLOCKS)=SELF%PSNDE(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PSNDE)

    CALL LOAD_AND_EXPAND('PMFU', SELF%PMFU, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPMFU,1:SELF%NBLOCKS)=SELF%PMFU(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PMFU)

    CALL LOAD_AND_EXPAND('PMFD', SELF%PMFD, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPMFD,1:SELF%NBLOCKS)=SELF%PMFD(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PMFD)

    CALL LOAD_AND_EXPAND('PA', SELF%PA, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPA,1:SELF%NBLOCKS)=SELF%PA(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PA)

    CALL LOAD_AND_EXPAND('PCLV', SELF%PCLV, KLON, SELF%KLEV, NCLV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PSUPSAT', SELF%PSUPSAT, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    SELF%ZIFG(1:NPROMA,1:SELF%KLEV,SELF%IPSUPSAT,1:SELF%NBLOCKS)=SELF%PSUPSAT(1:NPROMA,1:SELF%KLEV,1:SELF%NBLOCKS)
    DEALLOCATE(SELF%PSUPSAT)
    ! Note: The 0-sized array (KFLDX=0) seems to create problems when filled with
    ! data from the C-backend, causing memory corruption if enabled.
    ! CALL LOAD_AND_EXPAND('PEXTRA', SELF%PEXTRA, KLON, SELF%KLEV, SELF%KFLDX, NPROMA, NGPTOT, SELF%NBLOCKS)

    ! The STATE_TYPE arrays are tricky, as the AOSOA layout needs to be expictly
    ! unrolled at every step, and we rely on dirty hackery to do this.
    CALL FIELD_INIT(SELF%TENDENCY_LOC, SELF%B_LOC, NPROMA, SELF%KLEV, NCLV, SELF%NBLOCKS)
    CALL LOAD_AND_EXPAND_STATE('TENDENCY_CML', SELF%TENDENCY_CML, SELF%B_CML, &
         & KLON, SELF%KLEV, NCLV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_STATE('TENDENCY_TMP', SELF%TENDENCY_TMP, SELF%B_TMP, &
         & KLON, SELF%KLEV, NCLV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)

    ! Output fields are simply allocated and zero'd
    CALL FIELD_INIT(SELF%PRAINFRAC_TOPRFZ, NPROMA, SELF%NBLOCKS)
    CALL FIELD_INIT(SELF%PCOVPTOT, NPROMA, SELF%KLEV, SELF%NBLOCKS)
    CALL FIELD_INIT(SELF%PFSQLF, NPROMA, SELF%KLEV+1, SELF%NBLOCKS)
    CALL FIELD_INIT(SELF%PFSQIF, NPROMA, SELF%KLEV+1, SELF%NBLOCKS)
    CALL FIELD_INIT(SELF%PFCQLNG, NPROMA, SELF%KLEV+1, SELF%NBLOCKS)
    CALL FIELD_INIT(SELF%PFCQNNG, NPROMA, SELF%KLEV+1, SELF%NBLOCKS)
    CALL FIELD_INIT(SELF%PFSQRF, NPROMA, SELF%KLEV+1, SELF%NBLOCKS)
    CALL FIELD_INIT(SELF%PFSQSF, NPROMA, SELF%KLEV+1, SELF%NBLOCKS)
    CALL FIELD_INIT(SELF%PFCQRNG, NPROMA, SELF%KLEV+1, SELF%NBLOCKS)
    CALL FIELD_INIT(SELF%PFCQSNG, NPROMA, SELF%KLEV+1, SELF%NBLOCKS)
    CALL FIELD_INIT(SELF%PFSQLTUR, NPROMA, SELF%KLEV+1, SELF%NBLOCKS)
    CALL FIELD_INIT(SELF%PFSQITUR, NPROMA, SELF%KLEV+1, SELF%NBLOCKS)
    CALL FIELD_INIT(SELF%PFPLSL, NPROMA, SELF%KLEV+1, SELF%NBLOCKS)
    CALL FIELD_INIT(SELF%PFPLSN, NPROMA, SELF%KLEV+1, SELF%NBLOCKS)
    CALL FIELD_INIT(SELF%PFHPSL, NPROMA, SELF%KLEV+1, SELF%NBLOCKS)
    CALL FIELD_INIT(SELF%PFHPSN, NPROMA, SELF%KLEV+1, SELF%NBLOCKS)
    CALL FIELD_INIT(SELF%ZOFG, NPROMA,SELF%KLEV+1,17, SELF%NBLOCKS)

    ! Initialize global parameters from the input file
    CALL LOAD_SCALAR('PTSPHY', SELF%PTSPHY)
    CALL LOAD_SCALAR('LDSLPHY', SELF%LDSLPHY)
    CALL LOAD_SCALAR('LDMAINCALL', SELF%LDMAINCALL)
    CALL YOMCST_LOAD_PARAMETERS()
    CALL YOETHF_LOAD_PARAMETERS()
    CALL YRECLDP_LOAD_PARAMETERS()
    CALL YREPHLI_LOAD_PARAMETERS()

    CALL INPUT_FINALIZE()

  END SUBROUTINE CLOUDSC_GLOBAL_STATE_LOAD

  SUBROUTINE CLOUDSC_GLOBAL_STATE_VALIDATE(SELF, NPROMA, NGPTOT, NGPTOTG)
    ! Validate the correctness of output against reference data
    CLASS(CLOUDSC_GLOBAL_STATE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NGPTOT
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG

    REAL(KIND=JPRB), ALLOCATABLE :: PLUDE(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PCOVPTOT(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PRAINFRAC_TOPRFZ(:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQLF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQIF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQLNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQNNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQRF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQSF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQRNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQSNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQLTUR(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQITUR(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFPLSL(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFPLSN(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFHPSL(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFHPSN(:,:,:)
    TYPE(STATE_TYPE), ALLOCATABLE :: TENDENCY_LOC(:)
    REAL(KIND=JPRB), ALLOCATABLE :: B_LOC(:,:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: ZOFG(:,:,:,:)

    INTEGER(KIND=JPIM) :: NBLOCKS, KLON, KLEV, KFLDX, INEXT

    CALL INPUT_INITIALIZE(NAME='reference')

    NBLOCKS = (NGPTOT / NPROMA) + MIN(MOD(NGPTOT,NPROMA), 1)
    CALL LOAD_SCALAR('KLON', KLON)
    CALL LOAD_SCALAR('KLEV', KLEV)
    CALL LOAD_SCALAR('KFLDX', KFLDX)

    ! Write variable validation header
    IF (IRANK == 0) THEN
      print '(1X,A20,1X,A3,5(1X,A20))', &
           & 'Variable','Dim', 'MinValue','MaxValue','AbsMaxErr','AvgAbsErr/GP','MaxRelErr-%'
    END IF

    INEXT=1

    SELF%IPFPLSL        =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFPLSN        =OUTDRAD(INEXT,1,.TRUE.)
    
    SELF%IPFSQLF        =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFSQIF        =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFCQLNG       =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFCQNNG       =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFSQLTUR      =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFSQITUR      =OUTDRAD(INEXT,1,.TRUE.)

    SELF%IPFSQRF        =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFCQRNG       =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFCQSNG       =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFSQSF        =OUTDRAD(INEXT,1,.TRUE.)

 
    SELF%IPFHPSL        =OUTDRAD(INEXT,1,.TRUE.)
    SELF%IPFHPSN        =OUTDRAD(INEXT,1,.TRUE.)

        print *, "validate:   ",  SELF%IPFSQLF,  SELF%IPFSQIF,  SELF%IPFCQLNG, SELF%IPFCQNNG, SELF%IPFSQSF

    ! Load reference data and expand to our block layout
    CALL LOAD_AND_EXPAND('PLUDE', PLUDE, KLON, SELF%KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ALLOCATE(ZOFG(NPROMA,SELF%KLEV+1,17, NBLOCKS))

    CALL LOAD_AND_EXPAND('PCOVPTOT', PCOVPTOT, KLON, SELF%KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PRAINFRAC_TOPRFZ', PRAINFRAC_TOPRFZ, KLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQLF', PFSQLF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFSQLF,1:NBLOCKS) = PFSQLF(1:NPROMA,1:SELF%KLEV+1,1:NBLOCKS)

    CALL LOAD_AND_EXPAND('PFSQIF', PFSQIF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFSQIF,1:NBLOCKS) = PFSQIF(1:NPROMA,1:SELF%KLEV+1,1:NBLOCKS)

    CALL LOAD_AND_EXPAND('PFCQLNG', PFCQLNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFCQLNG,1:NBLOCKS)=PFCQLNG(1:NPROMA,1:SELF%KLEV+1,1:NBLOCKS)

    CALL LOAD_AND_EXPAND('PFCQNNG', PFCQNNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFCQNNG,1:NBLOCKS)=PFCQNNG(1:NPROMA,1:SELF%KLEV+1,1:NBLOCKS)

    CALL LOAD_AND_EXPAND('PFSQRF', PFSQRF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFSQRF,1:NBLOCKS)=PFSQRF(1:NPROMA,1:SELF%KLEV+1,1:NBLOCKS)

    CALL LOAD_AND_EXPAND('PFSQSF', PFSQSF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFSQSF,1:NBLOCKS)=PFSQSF(1:NPROMA,1:SELF%KLEV+1,1:NBLOCKS)

    CALL LOAD_AND_EXPAND('PFCQRNG', PFCQRNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFCQRNG,1:NBLOCKS)=PFCQRNG(1:NPROMA,1:SELF%KLEV+1,1:NBLOCKS)

    CALL LOAD_AND_EXPAND('PFCQSNG', PFCQSNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFCQSNG,1:NBLOCKS)=PFCQSNG(1:NPROMA,1:SELF%KLEV+1,1:NBLOCKS)

    CALL LOAD_AND_EXPAND('PFSQLTUR', PFSQLTUR, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFSQLTUR,1:NBLOCKS)=PFSQLTUR(1:NPROMA,1:SELF%KLEV+1,1:NBLOCKS)

    CALL LOAD_AND_EXPAND('PFSQITUR', PFSQITUR, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFSQITUR,1:NBLOCKS)=PFSQITUR(1:NPROMA,1:SELF%KLEV+1,1:NBLOCKS)

    CALL LOAD_AND_EXPAND('PFPLSL', PFPLSL, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFPLSL,1:NBLOCKS)=PFPLSL(1:NPROMA,1:SELF%KLEV+1,1:NBLOCKS)

    CALL LOAD_AND_EXPAND('PFPLSN', PFPLSN, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFPLSN,1:NBLOCKS)=PFPLSN(1:NPROMA,1:SELF%KLEV+1,1:NBLOCKS)

    CALL LOAD_AND_EXPAND('PFHPSL', PFHPSL, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFHPSL,1:NBLOCKS)=PFHPSL(1:NPROMA,1:SELF%KLEV+1,1:NBLOCKS)

    CALL LOAD_AND_EXPAND('PFHPSN', PFHPSN, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFHPSN,1:NBLOCKS)=PFHPSN(1:NPROMA,1:SELF%KLEV+1,1:NBLOCKS)

    CALL LOAD_AND_EXPAND_STATE('TENDENCY_LOC', TENDENCY_LOC, B_LOC, KLON, SELF%KLEV, NCLV, &
         & NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL INPUT_FINALIZE()

    ! Actual variable validation
    CALL VALIDATE('PLUDE', PLUDE, SELF%PLUDE, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PCOVPTOT', PCOVPTOT, SELF%PCOVPTOT, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PRAINFRAC_TOPRFZ', PRAINFRAC_TOPRFZ, SELF%PRAINFRAC_TOPRFZ, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
        CALL VALIDATE('PFSQLF',ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFSQLF,1:NBLOCKS) , SELF%ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFSQLF,1:NBLOCKS), NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQIF', ZOFG(1:NPROMA,1:SELF%KLEV+1, SELF%IPFSQIF,1:NBLOCKS), &
    &SELF%ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFSQIF,1:NBLOCKS), NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQLNG', ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFCQLNG,1:NBLOCKS), SELF%ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFCQLNG,1:NBLOCKS), NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
       ! print *, "_______________   ", SELF%PFCQLNG(109,120,83), "     ", SELF%PFCQLNG(24,120,25)

    CALL VALIDATE('PFCQNNG', ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFCQNNG,1:NBLOCKS),SELF%ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFCQNNG,1:NBLOCKS), NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQRF', ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFSQRF,1:NBLOCKS), SELF%ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFSQRF,1:NBLOCKS), NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQSF', ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFSQSF,1:NBLOCKS), SELF%ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFSQSF,1:NBLOCKS), NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQRNG', ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFCQRNG,1:NBLOCKS), SELF%ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFCQRNG,1:NBLOCKS), NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQSNG', ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFCQSNG,1:NBLOCKS), SELF%ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFCQSNG,1:NBLOCKS), NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQLTUR', ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFSQLTUR,1:NBLOCKS), &
    & SELF%ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFSQLTUR,1:NBLOCKS), NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQITUR',  ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFSQITUR,1:NBLOCKS), &
    & SELF%ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFSQITUR,1:NBLOCKS), NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFPLSL', ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFPLSL,1:NBLOCKS), SELF%ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFPLSL,1:NBLOCKS), NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFPLSN', ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFPLSN,1:NBLOCKS), SELF%ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFPLSN,1:NBLOCKS), NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFHPSL', ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFHPSL,1:NBLOCKS), SELF%ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFHPSL,1:NBLOCKS), NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFHPSN', ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFHPSN,1:NBLOCKS), &
    & SELF%ZOFG(1:NPROMA,1:SELF%KLEV+1,SELF%IPFHPSN,1:NBLOCKS), NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    !CALL VALIDATE('PFSQLF', PFSQLF, SELF%PFSQLF, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    !CALL VALIDATE('PFSQIF', PFSQIF, SELF%PFSQIF, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    !CALL VALIDATE('PFCQLNG', PFCQLNG, SELF%PFCQLNG, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    !CALL VALIDATE('PFCQNNG', PFCQNNG, SELF%PFCQNNG, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    !CALL VALIDATE('PFSQRF', PFSQRF, SELF%PFSQRF, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    !CALL VALIDATE('PFSQSF', PFSQSF, SELF%PFSQSF, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    !CALL VALIDATE('PFCQRNG', PFCQRNG, SELF%PFCQRNG, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    !CALL VALIDATE('PFCQSNG', PFCQSNG, SELF%PFCQSNG, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    !CALL VALIDATE('PFSQLTUR', PFSQLTUR, SELF%PFSQLTUR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    !CALL VALIDATE('PFSQITUR', PFSQITUR, SELF%PFSQITUR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
   ! CALL VALIDATE('PFPLSL', PFPLSL, SELF%PFPLSL, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
   ! CALL VALIDATE('PFPLSN', PFPLSN, SELF%PFPLSN, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    !CALL VALIDATE('PFHPSL', PFHPSL, SELF%PFHPSL, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    !CALL VALIDATE('PFHPSN', PFHPSN, SELF%PFHPSN, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    ! This is extremly hacky, but the array-of-struct-of-array layout demands it.
    CALL VALIDATE('TENDENCY_LOC%A', B_LOC(:,:,2,:), SELF%B_LOC(:,:,2,:), NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('TENDENCY_LOC%Q', B_LOC(:,:,3,:), SELF%B_LOC(:,:,3,:), NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('TENDENCY_LOC%T', B_LOC(:,:,1,:), SELF%B_LOC(:,:,1,:), NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('TENDENCY_LOC%CLD', B_LOC(:,:,4:,:), SELF%B_LOC(:,:,4:,:), NPROMA, SELF%KLEV, NCLV, NGPTOT, NBLOCKS, NGPTOTG)

  END SUBROUTINE CLOUDSC_GLOBAL_STATE_VALIDATE

    INTEGER(KIND=JPIM) FUNCTION INDRAD(KNEXT,KFLDS,LDUSE)
    INTEGER(KIND=JPIM),INTENT(INOUT) :: KNEXT
    INTEGER(KIND=JPIM),INTENT(IN) :: KFLDS
    LOGICAL,INTENT(IN) :: LDUSE

    IF( LDUSE )THEN
      INDRAD=KNEXT
      KNEXT=KNEXT+KFLDS
    ENDIF

    END FUNCTION INDRAD


    INTEGER(KIND=JPIM) FUNCTION OUTDRAD(KNEXT,KFLDS,LDUSE)
    INTEGER(KIND=JPIM),INTENT(INOUT) :: KNEXT
    INTEGER(KIND=JPIM),INTENT(IN) :: KFLDS
    LOGICAL,INTENT(IN) :: LDUSE

    IF( LDUSE )THEN
      OUTDRAD=KNEXT
      KNEXT=KNEXT+KFLDS
    ENDIF

    END FUNCTION OUTDRAD
END MODULE CLOUDSC_GLOBAL_STATE_MOD
