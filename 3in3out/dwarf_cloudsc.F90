! (C) Copyright 1988- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
!
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

PROGRAM DWARF_CLOUDSC

USE PARKIND1, ONLY: JPIM, JPIB
USE CLOUDSC_MPI_MOD, ONLY: CLOUDSC_MPI_INIT, CLOUDSC_MPI_END, NUMPROC, IRANK
USE CLOUDSC_GLOBAL_STATE_MOD, ONLY: CLOUDSC_GLOBAL_STATE
USE CLOUDSC_DRIVER_MOD, ONLY: CLOUDSC_DRIVER
USE EC_PMON_MOD, ONLY: EC_PMON

USE YOECLDP  , ONLY : YRECLDP
USE YOMCST   , ONLY : YRCST 
USE YOETHF   , ONLY : YRTHF

IMPLICIT NONE

CHARACTER(LEN=20) :: CLARG
INTEGER(KIND=JPIM) :: IARGS, LENARG, JARG, I

INTEGER(KIND=JPIM) :: NUMOMP   = 1     ! Number of OpenMP threads for this run
INTEGER(KIND=JPIM) :: NGPTOTG  = 16384 ! Number of grid points (as read from command line)
INTEGER(KIND=JPIM) :: NPROMA   = 32    ! NPROMA blocking factor (currently active)
INTEGER(KIND=JPIM) :: NGPTOT           ! Local number of grid points

TYPE(CLOUDSC_GLOBAL_STATE) :: GLOBAL_STATE

INTEGER(KIND=JPIB) :: ENERGY, POWER
CHARACTER(LEN=1)   :: CLEC_PMON


CALL GET_ENVIRONMENT_VARIABLE('EC_PMON', CLEC_PMON)
IF (CLEC_PMON == '1') THEN
  CALL EC_PMON(ENERGY, POWER)
  print *, "EC_PMON:: Initial (idle) power: ", POWER
END IF

IARGS = COMMAND_ARGUMENT_COUNT()

! Get the number of OpenMP threads to use for the benchmark
if (IARGS >= 1) then
   CALL GET_COMMAND_ARGUMENT(1, CLARG, LENARG)
   READ(CLARG(1:LENARG),*) NUMOMP
end if

! Initialize MPI environment
CALL CLOUDSC_MPI_INIT(NUMOMP)

! Get total number of grid points (NGPTOT) with which to run the benchmark
IF (IARGS >= 2) THEN
  CALL GET_COMMAND_ARGUMENT(2, CLARG, LENARG)
  READ(CLARG(1:LENARG),*) NGPTOTG
END IF

! Determine local number of grid points
NGPTOT = (NGPTOTG - 1) / NUMPROC + 1
if (IRANK == NUMPROC - 1) then
  NGPTOT = NGPTOTG - (NUMPROC - 1) * NGPTOT
end if

! Get the block size (NPROMA) for which to run the benchmark  
IF (IARGS >= 3) THEN
  CALL GET_COMMAND_ARGUMENT(3, CLARG, LENARG)
  READ(CLARG(1:LENARG),*) NPROMA
ENDIF

 print *, " *********************", NGPTOT
! TODO: Create a global global memory state from serialized input data
CALL GLOBAL_STATE%LOAD(NPROMA, NGPTOT, NGPTOTG)

! Call the driver to perform the parallel loop over our kernel
CALL CLOUDSC_DRIVER( NUMOMP, NPROMA, GLOBAL_STATE%KLEV, NGPTOT, NGPTOTG, &
     & GLOBAL_STATE%KFLDX, GLOBAL_STATE%PTSPHY, &
     & GLOBAL_STATE%IPT, GLOBAL_STATE%IPQ, &
     & GLOBAL_STATE%TENDENCY_CML, GLOBAL_STATE%TENDENCY_TMP, GLOBAL_STATE%TENDENCY_LOC, &
     & GLOBAL_STATE%IPVFA,    GLOBAL_STATE%IPVFL,  GLOBAL_STATE%IPVFI, &
     & GLOBAL_STATE%IPDYNA,   GLOBAL_STATE%IPDYNL, GLOBAL_STATE%IPDYNI, &
     & GLOBAL_STATE%IPHRSW,   GLOBAL_STATE%IPHRLW, &
     & GLOBAL_STATE%IPVERVEL, GLOBAL_STATE%IPAP,   GLOBAL_STATE%IPAPH, &
     & GLOBAL_STATE%PLSM,    GLOBAL_STATE%LDCUM, GLOBAL_STATE%KTYPE, &
     & GLOBAL_STATE%IPLU,     GLOBAL_STATE%PLUDE, GLOBAL_STATE%IPSNDE, &
     & GLOBAL_STATE%IPMFU,    GLOBAL_STATE%IPMFD, &
     & GLOBAL_STATE%IPA,      GLOBAL_STATE%PCLV,  GLOBAL_STATE%IPSUPSAT,&
     & GLOBAL_STATE%IPLCRIT_AER, GLOBAL_STATE%IPICRIT_AER, GLOBAL_STATE%IPRE_ICE, &
     & GLOBAL_STATE%IPCCN,     GLOBAL_STATE%IPNICE,&
     & GLOBAL_STATE%PCOVPTOT, GLOBAL_STATE%PRAINFRAC_TOPRFZ, &
     & GLOBAL_STATE%IPFSQLF,   GLOBAL_STATE%IPFSQIF ,  GLOBAL_STATE%IPFCQNNG,  GLOBAL_STATE%IPFCQLNG, &
     & GLOBAL_STATE%IPFSQRF,   GLOBAL_STATE%IPFSQSF ,  GLOBAL_STATE%IPFCQRNG,  GLOBAL_STATE%IPFCQSNG, &
     & GLOBAL_STATE%IPFSQLTUR, GLOBAL_STATE%IPFSQITUR, &
     & GLOBAL_STATE%IPFPLSL,   GLOBAL_STATE%IPFPLSN,   GLOBAL_STATE%IPFHPSL,   GLOBAL_STATE%IPFHPSN, &
     & YRCST, YRTHF, YRECLDP, GLOBAL_STATE%ZIFG, GLOBAL_STATE%ZOFG)

! Validate the output against serialized reference data
CALL GLOBAL_STATE%VALIDATE(NPROMA, NGPTOT, NGPTOTG)

! Tear down MPI environment
CALL CLOUDSC_MPI_END()

END PROGRAM DWARF_CLOUDSC
